from matplotlib import pyplot as plt
import numpy as np
import pylab as pyl
import matplotlib as mpl

#Define constants of calibration curve and G0.
G0 = 7.74809173E-5 
C1 = -8.34535E-4 #Constants of hyperbolic calibration fit G = C1*V/(C2 + V)
C2 = 4.9537

def initview(filename):
	#Displays the raw voltage data within the calibration range.  
	data = np.genfromtxt(filename, delimiter = "\n")
	data = data[(data >= -3.28) & (data <= -0.35)] #Removes values that are outside the range of the calibration curve.
	plt.plot(data)
	plt.show()

def initconvert(filename):
    #Displays all data within the calibration range in units of G_0.
	data = np.genfromtxt(filename, delimiter = "\n")
	data = data[(data >= -3.28) & (data <= -0.35)] #Removes values that are outside the range of the calibration curve.
	data = (data*C1)/(data + C2) #Converts voltages into conductances via calibration curve.
	data /= G0 #Converts from Siemens to units of G0. 
	plt.ylabel(r"Conductance ($G_0$)")
	plt.xlabel(r"Time (arb. units)")
	plt.yticks(np.arange(0, 20, 1))
	plt.grid()
	plt.plot(data)
	plt.show()
	
def trimview(start, end, filename):
    #Displays a specific section of the raw voltage data.
	data = np.genfromtxt(filename, delimiter = "\n")
	data = data[(data >= -3.28) & (data <= -0.35)] #Removes values that are outside the range of the calibration curve.
	data = data[start:end]
	plt.plot(data)
	plt.show()
 
def gtrim(start, end, filename):
    #Displays a specific section of the data in units of G_0.
	data = np.genfromtxt(filename, delimiter = "\n")
	data = data[(data >= -3.28) & (data <= -0.35)] #Removes values that are outside the range of the calibration curve.
	data = data[start:end]
	data = (data*C1)/(data + C2) #Converts voltages into conductances via calibration curve.
	data /= G0 #Converts from Siemens to units of G0.
	plt.yticks(np.arange(0, 20, 1))
	plt.grid()
	plt.plot(data)
	plt.show()

def trimsave(start, end, filename, savename):
    #Saves a section of the raw voltage data for further analysis.
	data = np.genfromtxt(filename, delimiter = "\n")
	data = data[(data >= -3.28) & (data <= -0.35)] #Removes values that are outside the range of the calibration curve.
	data = data[start:end]
	np.savetxt(savename, data, delimiter = "\n")

def convertview(filename):
    #Gives a preview of what a small section of the data in terms of G_0 looks like. Best used on data trimmed using trimsave.
	data = np.genfromtxt(filename, delimiter = "\n")
	data = (data*C1)/(data + C2) #Converts voltages into conductances via calibration curve.
	data /= G0 #Converts from Siemens to units of G0.
	mpl.rc('font', family = 'Times New Roman')
	plt.grid()
	plt.ylabel(r"Conductance ($G_0$)", fontsize = 16)
	plt.xlabel(r"Time (arb. units)", fontsize = 16)
	plt.xticks(fontsize = 16)
	plt.yticks(fontsize = 16)
	plt.plot(data)
	plt.show()

def convertsave(filename, csvname, pdfname, ydown, yup, xdown, xup):
    #Same function as convertview, but saves the corresponding G_0 data as a csv, as well as the plot as a pdf.
	data = np.genfromtxt(filename, delimiter = "\n")
	data = (data*C1)/(data + C2) #Converts voltages into conductances via calibration curve.
	data /= G0 #Converts from Siemens to units of G0.
	plt.yticks(np.arange(np.floor(min(data)), np.ceil(max(data)) + 1, 1), fontsize = 14)
	plt.xticks(fontsize = 14)
	plt.xlim(xdown, xup)
	mpl.rc('font', family = 'Times New Roman') #Sets font in figures to Times New Roman, in line with most research papers.
	plt.ylabel(r"Conductance ($G_0$)", fontsize = 14)
	plt.xlabel(r"Time (arb. units)", fontsize = 14)
	plt.grid()
	plt.ylim(ydown, yup)
	plt.plot(data)
	plt.savefig(pdfname, pad_inches = 0)	
	np.savetxt(csvname, data, delimiter = "\n")

def histview(filename):
    #Plots G_0 data on a histogram from a file, used on data generated by convertsave.
	data = np.genfromtxt(filename, delimiter = "\n")
	sd = np.std(data)
	plt.grid()
	count = data.size
	binwidth = 3.49 * sd * np.power(count, -1/3) #Uses optimal bin size to avoid bias.
	plt.xticks(np.arange(np.floor(min(data)), np.ceil(max(data)), 1))
	plt.xlabel(r"Conductance ($G_0$)")
	plt.ylabel(r"Frequency (Normalised)")
	plt.hist(data, bins=np.arange(min(data), max(data) + binwidth, binwidth), normed = True)
	plt.show()
 
def histset(data):
    #As above, but with data taken from an array rather than a file. Best used for multiple data sets.
	sd = np.std(data)
	count = data.size
	binwidth = 3.49 * sd * np.power(count, -1/3) #Uses optimal bin size to avoid bias.
	plt.xticks(np.arange(np.floor(min(data)), np.ceil(max(data)), 1))
	plt.grid()
	plt.xlabel(r"Conductance ($G_0$)")
	plt.ylabel(r"Frequency (Normalised)")
	plt.hist(data, bins=np.arange(min(data), max(data) + binwidth, binwidth), normed = True)
	plt.show()
 
def histline(data):
    #Displays data from an array as a histogram, but with a line through bin centres.
	sd = np.std(data)
	count = data.size
	binwidth = 3.49 * sd * np.power(count, -1/3) #Uses optimal bin size to avoid bias.
	plt.xticks(np.arange(np.floor(min(data)), np.ceil(max(data)), 1))
	plt.grid()
	plt.xlabel(r"Conductance ($G_0$)")
	plt.ylabel(r"Frequency (Normalised)")
	mpl.rc('font', family = "Times New Roman")
	y, binEdges = np.histogram(data, bins=np.arange(min(data), max(data) + binwidth, binwidth), normed = True)
	bincentres = 0.5*(binEdges[1:]+binEdges[:-1])
	pyl.plot(bincentres, y, '-')
	#Uncomment below as necessary to either save or preview the line histogram.
	#pyl.savefig(FILEPATH AND NAME)
	#pyl.show()